# -*- coding: utf-8 -*-
"""modelling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ae1mUC4MCDlszLm23qg9N1jVetEl-VMQ
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# from google.colab import drive
# import warnings
# warnings.filterwarnings("ignore")
# drive.mount('/content/drive')

import pandas as pd
import os


football_files_path = "/content/drive/MyDrive/bookmaker-model/football/"
basketball_files_path = "/content/drive/MyDrive/bookmaker-model/basketball/"

football_csv_files = os.listdir(football_files_path)
football_csv_files = [football_files_path + e for e in football_csv_files if not e.startswith('.') ]

basketball_csv_files = os.listdir(basketball_files_path)
basketball_csv_files = [basketball_files_path + e for e in basketball_csv_files if not e.startswith('.') ]

def create_df(file_paths):
    full_data = pd.DataFrame()
    for file in file_paths:
        with open(file) as file_in:
            print(f"reading {file}")
            part_df = pd.read_csv(file)
            full_data = pd.concat([full_data, part_df], axis=0)

    return full_data

football_df = create_df(football_csv_files)
basketball_df = create_df(basketball_csv_files)

football_df.columns = ['match', 'bookmaker', 'home-odds', 'draw-odds', 'away-odds', 'date', 'score']
football_df.shape

basketball_df.columns = ['match', 'bookmaker', 'home-odds', 'away-odds', 'date', 'score']
basketball_df.shape

basketball_df.head()

football_df.head()

"""## Unique bookmakers"""

football_df['bookmaker'].unique()

basketball_df['bookmaker'].unique()

"""# Preprocess

1. create a column describing the match result: home, draw, or away win
2. convert the odds to probability

## Clean data

there is columns that does not retrieve data.
Thankfully, it's only few dozens
"""

def data_cleaninig(df: pd.DataFrame) -> pd.DataFrame:
  df = df.drop(df[df['home-odds'] == '-'].index)
  df = df.drop(df[df['away-odds'] == '-'].index)
  return df

football_df = data_cleaninig(football_df)
basketball_df = data_cleaninig(basketball_df)

"""## Create home, away team column"""

def parse_home_away_team(match_between):
  """
  Ex: 'Manchester Utd\n0\n–\nLiverpool\n3'
  to filter out the score, use isnumeric()
  """

  parts = match_between.split('\n')
  parts = [each for each in parts if not each.isnumeric()]

  # sample output list: ['Manchester Utd', '–', 'Liverpool']
  return parts[0], parts[-1]


football_df['home'], football_df['away'] = zip(*football_df['match'].map(parse_home_away_team))
football_df.drop('match', axis=1, inplace=True)

basketball_df['home'], basketball_df['away'] = zip(*basketball_df['match'].map(parse_home_away_team))
basketball_df.drop('match', axis=1, inplace=True)

"""## Create column *match-result*"""

def create_match_result_football(score)-> str:
  """
  football match, results are in format '3:2'
  """
  parts = score.split(':')
  home = int(parts[0])
  away = int(parts[1])
  if home > away:
      'home'
      return 0
  elif home == away:
      'draw'
      return 1
  else:
      'away'
      return 2


def create_match_result_basketball(score)-> str:
    """
    In basketball match, the game results might be in format '108:105 OT (99:99)' or '98:100'
    """
    if 'OT' in score:
      parts = score.split('OT') # ['108:105 ', ' (99:99)']
      score = parts[0].strip()  # '108:105'
      parts = score.split(':')
      home = int(parts[0])
      away = int(parts[1])
    else:
      parts = score.split(':')
      home = int(parts[0])
      away = int(parts[1])


    if home > away:
      'home'
      return 0
    else:
      'away'
      return 1

    raise RuntimeError(f"When creating the match result, errors occur: sport{sport}, score {score}")


football_df['match-result'] = football_df['score'].apply(create_match_result_football)
basketball_df['match-result'] = basketball_df['score'].apply(create_match_result_basketball)

"""### add datetime"""

football_df['date'] = pd.to_datetime(football_df['date'])
basketball_df['date'] = pd.to_datetime(basketball_df['date'])

"""Save as sqlite cuz the add elo process takes a lot of time if running by pandas"""

# import sqlite3
# conn = sqlite3.connect('/content/drive/MyDrive/bookmaker-model/merge.sqlite')
# football_df.to_sql("football", conn, if_exists="replace", index=False)
# conn.close()

"""## Add elo ranking

1. parse datetime object
2. use datetime to find the elo rating

### read from sqlite database
"""

def sanitize_team_name(name):
    team_name = name
    ###
    ### process the name
    sanitized = team_name.lower()
    # exception team name

    team_club_abbr_dict = {
        'manchester utd': 'man united',
        'manchester city': 'man city',
        'sheffield utd': 'sheffield united',
        }
    if sanitized in team_club_abbr_dict.keys():


        sanitized =  team_club_abbr_dict[sanitized]

    return str(sanitized)

def exec_query(query):
    import sqlite3
    conn = sqlite3.connect('/content/drive/MyDrive/bookmaker-model/merge.sqlite')
    df = pd.read_sql(query, conn)
    conn.close()
    return df

def get_elo():
    query = """
    SELECT
      game.bookmaker,
      game.`home-odds`,
      game.`draw-odds`,
      game.`away-odds`,
      game.`match-result`,
      game.date as match_date,
      game.home_alias as home_alias,
      game.away_alias as away_alias,
      homeElo.Elo as home_elo,
      awayElo.Elo as away_elo
    FROM football as game
    INNER JOIN `elo.sqlite` as homeElo
    ON game.home_alias = homeElo.club
    INNER JOIN `elo.sqlite` as awayElo
    ON game.away_alias = awayElo.club
    WHERE game.date BETWEEN homeElo.from_date AND homeElo.to_date
    AND game.date BETWEEN awayElo.from_date AND awayElo.to_date;
    """
    df = exec_query(query)
    return df

# football_df['date'] = football_df['date'].dt.strftime('%Y-%m-%d')
# football_df['home-elo'] = football_df.apply(get_elo, play_at='home', axis=1)
# football_df['away-elo'] = football_df.apply(get_elo, play_at='away', axis=1)
football_df.shape

# Commented out IPython magic to ensure Python compatibility.
# %%time
# full = get_elo()

print(full.shape)
full.head()

full['home_elo'] = full['home_elo'].apply(lambda e : round(e))
full['away_elo'] = full['away_elo'].apply(lambda e : round(e))
full.head()

football_df = full

"""### Is there such thing as home advantage?

Let's see how many home game have won
"""

(home, draw, away) = football_df['match-result'].value_counts()
print(f"Home won:{home}, draw: {draw}, away won: {away}")

(home, away) = basketball_df['match-result'].value_counts()

print(f"Home won: {home}, away won: {away}")

"""## convert odds to probability

### Football
"""

import numpy as np

def convert_american_to_decimal(odds):
  float_odds = np.float32(odds)
  if float_odds > 0:
      return (float_odds / 100) + 1
  if float_odds < 0:
      return (100 / -float_odds) + 1
  if float_odds == 0:
      return 0
  raise Exception("How could this happen?" + float_odds)


def convert_to_probability(decimal):
    probability = (1 / decimal)
    return round(probability, 3)


def get_margin_of_three_odds(margin):
    """
    probability over 1, multiply by margin will be the odds:
    (1/prob) * margin = odd
    There are 3 odds available, we assume the margin is a fixed percentage for each odd
    home_odd + draw_odd + away_odd = total payout
    (1/home_prob) * margin + (1/draw_prob) * margin + (1/away_prob) * margin = total payout
    to get the margin, we simply calculate the cube root of the overround
    """
    return margin ** (1/3)

football_decimal_list = ['decimal-home', 'decimal-draw', 'decimal-away']
football_odds_list = ['home-odds', 'draw-odds', 'away-odds']


for decimal, odds in zip(football_decimal_list, football_odds_list):
  football_df[decimal] = football_df[odds].apply(convert_american_to_decimal)


football_prob_list = ['probability-home', 'probability-draw', 'probability-away']
for probability, decimal_target in zip(football_prob_list, football_decimal_list):
  football_df[probability] = football_df[decimal_target].apply(convert_to_probability)


football_df['overround'] = football_df['probability-home'] + football_df['probability-draw'] + football_df['probability-away'] - 1

football_df['margin'] = football_df['overround'].apply(get_margin_of_three_odds)

football_df.sample(5)

"""### basketball"""

basketball_odds_list = ['home-odds', 'away-odds']
basketball_decimal_list = ['decimal-home', 'decimal-away']

for decimal, odds in zip(basketball_decimal_list, basketball_odds_list):
  basketball_df[decimal] = basketball_df[odds].apply(convert_american_to_decimal)


basketball_prob_list = ['probability-home', 'probability-away']
for probability, decimal_target in zip(basketball_prob_list, basketball_decimal_list):
  basketball_df[probability] = basketball_df[decimal_target].apply(convert_to_probability)


basketball_df['overround'] = basketball_df['probability-home'] + basketball_df['probability-away'] - 1

basketball_df['margin'] = basketball_df['overround'].apply(get_margin_of_three_odds)
basketball_df.sample(5)

"""### standard scale"""

from sklearn.preprocessing import StandardScaler

football_df[['home_elo_std', 'away_elo_std']] = StandardScaler().fit_transform(football_df[['home_elo', 'away_elo']])
football_df.head()



"""## Ensemble modelling: soft vote

### Football
"""

df = football_df

unibet_df = df[df['bookmaker'] == 'Unibet']
william_hill_df = df[df['bookmaker'] == 'William Hill']
bet365_df = df[df['bookmaker'] == 'bet365']

other_bookmakers = df[~df['bookmaker'].isin(['Unibet', 'William Hill', 'bet365'])]

df_list = [unibet_df, william_hill_df, bet365_df, other_bookmakers]

for df, name in zip(df_list, ['unibet', 'william hill', 'bet365', 'others']):
  print(f"{df.shape}: {name}")

from sklearn.model_selection import train_test_split

x_var = ['probability-draw', 'probability-away', 'home_elo_std', 'away_elo_std']
# x_var = ['decimal-home', 'decimal-draw','decimal-away']
y = ['probability-home']

unibet_x_train , unibet_x_test, unibet_y_train, unibet_y_test = train_test_split(unibet_df[x_var], unibet_df[y], random_state=0)
william_hill_x_train , william_hill_x_test, william_hill_y_train, william_hill_y_test = train_test_split(william_hill_df[x_var], william_hill_df[y], random_state=0)
bet365_x_train , bet365_x_test, bet365_y_train, bet365_y_test = train_test_split(bet365_df[x_var], bet365_df[y], random_state=0)
other_x_train , other_x_test, other_y_train, other_y_test = train_test_split(other_bookmakers[x_var], other_bookmakers[y], random_state=0)

from sklearn.linear_model import BayesianRidge
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import VotingRegressor

reg1 = GradientBoostingRegressor(random_state=1)
reg2 = RandomForestRegressor(random_state=1)
reg3 = BayesianRidge()

reg1 = reg1.fit(other_x_train, other_y_train)
reg2 = reg2.fit(other_x_train, other_y_train)
reg3 = reg3.fit(other_x_train, other_y_train)

# consensus model
ereg = VotingRegressor(estimators=[('gb', reg1), ('rf', reg2), ('br', reg3)])
ereg = ereg.fit(bet365_x_train, bet365_y_train)

"""#### Evaluate model"""

from sklearn.metrics import mean_squared_error
import numpy as np
y_true = other_y_test
y_pred = ereg.predict(other_x_test)
score = np.sqrt(mean_squared_error(y_true, y_pred))
print("The RMSE of Model is {}".format(round(score, 2)))

import matplotlib.pyplot as plt

xt = other_x_train[:20]

pred1 = reg1.predict(xt)
pred2 = reg2.predict(xt)
pred3 = reg3.predict(xt)
pred4 = ereg.predict(xt)

plt.figure()
plt.plot(pred1, "gd", label="GradientBoostingRegressor")
plt.plot(pred2, "b^", label="RandomForestRegressor")
plt.plot(pred3, "ys", label="BayesianRidge")
plt.plot(pred4, "r*", ms=10, label="VotingRegressor")

plt.tick_params(axis="x", which="both", bottom=False, top=False, labelbottom=False)
plt.ylabel("predicted")
plt.xlabel("training samples")
plt.legend(loc="best")
plt.title("Regressor predictions and their average")

plt.show()

"""### Basketball"""

df = basketball_df

unibet_df = df[df['bookmaker'] == 'Unibet']
william_hill_df = df[df['bookmaker'] == 'William Hill']
bet365_df = df[df['bookmaker'] == 'bet365']

other_bookmakers = df[~df['bookmaker'].isin(['Unibet', 'William Hill', 'bet365'])]

df_list = [unibet_df, william_hill_df, bet365_df, other_bookmakers]

for df, name in zip(df_list, ['unibet', 'william hill', 'bet365', 'others']):
  print(f"{df.shape}: {name}")

x_var = ['decimal-home', 'decimal-away']
y = ['match-result']

unibet_x_train , unibet_x_test, unibet_y_train, unibet_y_test = train_test_split(unibet_df[x_var], unibet_df[y], random_state=0)
william_hill_x_train , william_hill_x_test, william_hill_y_train, william_hill_y_test = train_test_split(william_hill_df[x_var], william_hill_df[y], random_state=0)
bet365_x_train , bet365_x_test, bet365_y_train, bet365_y_test = train_test_split(bet365_df[x_var], bet365_df[y], random_state=0)
other_x_train , other_x_test, other_y_train, other_y_test = train_test_split(other_bookmakers[x_var], other_bookmakers[y], random_state=0)

"""## Save the model"""

# save to file
from joblib import dump

dump(ereg, '/content/drive/MyDrive/model.pkl')

ensemble_model.predict([[0.4, 0.1, 0.5,]])

